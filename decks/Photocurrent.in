#
# This is a simulation of a thin slab of Si, a photoconductor.
#
# 07/16/2020

# Experimental Variables

# Length of the silicon substrate, in microns.
set si_len = 100
# Material used as the dopant.
set dopant_m = phosphorus
# Concentration of the dopant.
set dopant_c = 1e15
# Type of the dopant.
if cond = ($dopant_m = phosphorus)
  set dopant_t=Nsub
else cond = ($dopant_m = boron)
  set dopant_t=Psub
if.end

# File Paths

# Name of the experiment.
set exp_name = "PC_${si_len}um_${dopant_t}${dopant_c}"
# Name of the structure file.
set file_str = "${exp_name}.str"
# Name of the log file for varying voltage.
set file_volt_log = "${exp_name}_voltage.log"
# Name of the log file for varying time.
set file_time_log = "${exp_name}_time.log"
# Name of the solution file.
set file_sta = "${exp_name}.sta"

# Start the Athena simulator, for creating the structure.
go athena

# Define the initial rectangular grid. Make it 1 micron wide, and a given
# length long.
line x loc=0 spac=0.5
line x loc=1 spac=0.5
line y loc=0 spac=0.1
line y loc=$si_len spac=0.1

# Define the initial substrate from the rectangular grid. Use silicon as
# the starting material, with a given dopant concentration.
# Since we specify phosphorus here, Athena will look up the c.resistivity value
# from the internal resistivity vs. concentration tables, which can be used for
# boron, phosphorus, arsenic, and antimony.
init silicon c.$dopant_m=$dopant_c orientation=100 two.d

# Length of the aluminum deposits, in microns.
set al_len = 1

# Deposit a layer of aluminum at the top.
deposit aluminum thick=$al_len division=5

# Deposit a layer of aluminum at the bottom.
structure flip.y
deposit aluminum thick=$al_len division=5
structure flip.y

# Define the upper aluminum material region as an electrode.
electrode name=cathode x=0.5 y=-0.1
# Define the lower aluminum material region as an electrode
electrode name=substrate x=0.5 y=$si_len+0.1

# Save the mesh to the structure file.
struct outf=$file_str

# Open the mesh in TonyPlot.
#tonyplot $file_str
#quit

# Start the Atlas simulator, for simulating the physics.
go atlas

# Read the mesh from the structure file.
mesh inf=$file_str

# Configure the electrodes as ohmic.
contact name=substrate neutral
contact name=cathode neutral
# Configure the electron and hole lifetime parameters.
material region=1 taun0=1e-7 taup0=1e-7
# Enable default models used for bipolar devices.
models bipolar
# Use Newton's method for solving, specifying the amount of carrier continuity
# equations to solve, whether to reduce electrode bias steps if the solution
# diverges, the amount of allowed outer loops, the amount of allowed trap
# procedures, and the maximum time-step.
method newton carriers=2 trap itlimit=20 maxtraps=10 dt.max=0.02e-9

# Introduce a Single Event Upset, with a given number of electron-hole pairs,
# moving with a given radius.
singleeventupset entrypoint="0,50" exitpoint="1,50" pcunits b.density=1.0e-5 \
    radialgauss radius=1 t0=2.e-11 tc=0

# Solve with all voltages set to 0.
solve initial
# Include the net charge in the output.
output charge
# Forward any voltage/current data generated by "solve" while varying the
# voltage to the log file.
log outf=$file_volt_log
# Solve with an increasingly high voltage applied to the substrate electrode.
solve vsubstrate=0 vstep=0.5 vfinal=1 name=substrate
# Save the structure and solution to the solution file.
save outf=$file_sta

# Forward any voltage/current data generated by "solve" while varying the
# time to the log file.
log outf=$file_time_log

# Run initial simulations, for certain times. This is done seperate from the
# other loop because we might want the solutions to be closer together in the
# beginning. For example, it could be set up so that it simulates:
#   0ns -> 1ns
#   2ns -> 5ns
#   5ns -> 10ns
#   (i-1)*20ns -> i*20ns, where i starts at 1.
# To support this pattern of non-regular intervals and then regular intervals,
# we have this loop of predefined times, and then a loop with a time delta.
#
# Within *this* loop, we can prevent simulating the same interval (e.g. 0-1ns)
# more than once by using the stopping time of the last simulation of the
# starting simulation of the current simulation. What's nice is that DeckBuild
# sorts integer arrays in increasing order, which helps ensure that this will
# work
#
# !!! Ensure that the loop steps here match the length of $t_final_arr! !!!
set last_tfinal=0
loop steps=4
  # Set the time to start at.
  assign name=t_step n.value=$last_tfinal
  # Set the times to end at.
  assign name=t_final_arr n.value=(1e-9, 2e-9, 5e-9, 10e-9)
  # Set the maximum time-step. This represents the intervals over which the
  # simulation runs, in order to get from t_step to t_final. In a sense, this
  # seems to control the "resolution" of the simulations. As the times get
  # larger, this is scaled up alongside it.
  # TODO: Should this be tweaked?
  assign name=dt_max n.value=0.5e-9

  # Reconfigure the solving method.
  method newton carriers=2 trap itlimit=20 maxtraps=10 dt.max=$dt_max
  solve tstep=$t_step tfinal=$t_final_arr
  save outf=${exp_name}_after${t_final_arr}s.sta

  # Alleviate the issue of redundancy by storing where we left of, so we can
  # pick back up, next iteration.
  set last_tfinal=$t_final_arr
l.end

# Transient time = length traveled/velocity, where l=100microns, v=mu/E, where mu is electron mobility, where E is voltage applied/length. Should be close to 100ns.
# See hole conc.

# Run simulations over a constant time delta. 20ns is a pretty good interval to
# start with. With a delta of 20ns, for the number of loop steps, ~30 is good
# for collecting a baseline (and ensuring that enough data is collected), going
# up to >600ns. For non-baseline data collection, ~8 is enough;
#
# From last loop to this loop, it would be possible to prevent redundancy, but
# doing so could result in messy filenames. For example, if we picked up at
# 1ns and ran with a delta of 25ns, then that 1ns will be added to all of the
# "after" suffixes.
set delta=25e-9
loop steps=20
  assign name=t_step n.value=0 delta=$delta
  assign name=t_final n.value=$t_step+$delta delta=$delta
  assign name=dt_max n.value=0.5e-9

  # Reconfigure the solving method.
  method newton carriers=2 trap itlimit=20 maxtraps=10 dt.max=$dt_max
  solve tstep=$t_step tfinal=$t_final
  save outf=${exp_name}_after${t_final}s.sta
l.end

# Open the solution in TonyPlot.
#tonyplot $file_sta $file_log
