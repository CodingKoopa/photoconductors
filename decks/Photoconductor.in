#
# This is a simulation of a thin slab of Si, a photoconductor.
#
# 07/16/2020

# Experimental Variables

# Length of the silicon substrate, in ÃŽÂ¼m.
set si_len = 100
# Material used as the dopant.
set dopant_m = phosphorus
# Concentration of the dopant.
# Diode is 1e12.
set dopant_c = 1e15
# Type of the dopant.
if cond = ($dopant_m = phosphorus)
  set dopant_t = Nsub
else cond = ($dopant_m = boron)
  set dopant_t = Psub
if.end
# Lifetime of electrons and electron holes, in s.
set lifetime = 1e-7
# Density of the electron/hole pairs, in pC/ÃŽÂ¼m.
set ehp_density = 1e-5

# File Paths

# Name of the experiment. Don't append variables to this unless they deviate
# from the default of the current baseline.
set exp_name = "PC"
if cond = ($si_len ^= 100)
  set exp_name = "${exp_name}_${si_len}um"
if.end
if cond = ($dopant_t ^= Nsub)
  set exp_name = "${exp_name}_${dopant_t}"
if.end
if cond = ($dopant_c ^= 1e15)
  set exp_name = "${exp_name}_${dopant_c}"
if.end
if cond = ($lifetime ^= 1e-7)
  set exp_name = "${exp_name}_lifetime${lifetime}"
if.end
if cond = ($ehp_density ^= 1e-5)
  set exp_name = "${exp_name}_ehpdensity${ehp_density}"
if.end
# Name of the structure file.
set file_str = "${exp_name}.str"
# Name of the log file for varying voltage.
set file_volt_log = "${exp_name}_voltage.log"
# Name of the log file for varying time.
set file_time_log = "${exp_name}_time.log"
# Name of the solution file.
set file_sta = "${exp_name}.sta"

# Start the Athena simulator, for creating the structure.
go athena

# Define the initial rectangular grid. Make it 1 micron wide, and a given
# length long.
line x loc=0 spac=0.5
line x loc=1 spac=0.5
line y loc=0 spac=0.1
line y loc=$si_len spac=0.1

# Define the initial substrate from the rectangular grid. Use silicon as
# the starting material, with a given dopant concentration.
# Since we specify phosphorus here, Athena will look up the c.resistivity value
# from the internal resistivity vs. concentration tables, which can be used for
# boron, phosphorus, arsenic, and antimony.
init silicon c.$dopant_m=$dopant_c orientation=100 two.d

# Add Boron doping to the edge.
#implant boron dose=1.0e15 energy=10 tilt=0 rotation=0 amorph

# Length of the aluminum deposits, in microns.
set al_len = 1

# Deposit a layer of aluminum at the top.
deposit aluminum thick=$al_len division=5

# Deposit a layer of aluminum at the bottom.
structure flip.y
# Dope the aluminum a little.
#implant phosphor dose=1.0e15 energy=10 tilt=0 rotation=0 amorph 
deposit aluminum thick=$al_len division=5
structure flip.y

# Define the upper aluminum material region as an electrode.
electrode name=cathode x=0.5 y=-0.1
# Define the lower aluminum material region as an electrode
electrode name=substrate x=0.5 y=$si_len+0.1

# Save the mesh to the structure file.
struct outf=$file_str

# Start the Atlas simulator, for simulating the physics.
go atlas

# Read the mesh from the structure file.
mesh inf=$file_str

# Configure the electrodes as ohmic.
contact name=substrate neutral
contact name=cathode neutral
# Configure the electron and hole lifetime parameters.
material region=1 taun0=$lifetime taup0=$lifetime
# Enable default models used for bipolar devices.
models bipolar
# Use Newton's method for solving, specifying the amount of carrier continuity
# equations to solve, whether to reduce electrode bias steps if the solution
# diverges, the amount of allowed outer loops, the amount of allowed trap
# procedures, and the maximum time-step.
method newton carriers=2 trap itlimit=20 maxtraps=10 dt.max=0.02e-9

# Introduce a Single Event Upset, with a given number of electron-hole pairs,
# moving with a given radius.
singleeventupset entrypoint="0,50" exitpoint="1,50" pcunits \
    b.density=$ehp_density radialgauss radius=1 t0=2.e-11 tc=0

# Solve with all voltages set to 0.
solve initial
# Include the net charge in the output.
output charge e.mobility h.mobility
# Forward any voltage/current data generated by "solve" while varying the
# voltage to the log file.
log outf=$file_volt_log
# Solve with an increasingly high voltage applied to the substrate electrode.
# TODO: diode is 10v
solve vsubstrate=0 vstep=0.5 vfinal=1 name=substrate
# Save the structure and solution to the solution file.
save outf=$file_sta

# Forward any voltage/current data generated by "solve" while varying the
# time to the log file.
log outf=$file_time_log

# Run initial simulations, for certain times. This is done seperate from the
# other loop because we might want the solutions to be closer together in the
# beginning. For example, it could be set up so that it simulates:
#   0ns -> 1ns
#   2ns -> 5ns
#   5ns -> 10ns
#   (i-1)*20ns -> i*20ns, where i starts at 1.
# To support this pattern of non-regular intervals and then regular intervals,
# we have this loop of predefined times, and then a loop with a time delta.
#
# Within *this* loop, we can prevent simulating the same interval (e.g. 0-1ns)
# more than once by using the stopping time of the last simulation of the
# starting simulation of the current simulation. What's nice is that DeckBuild
# sorts integer arrays in increasing order, which helps ensure that this will
# work
#
# !!! Ensure that the loop steps here match the length of $t_final_arr! !!!
# try 0.1ns dt.max for diode
set last_tfinal=0
loop steps=4
  # Set the time to start at.
  assign name=t_step n.value=$last_tfinal
  # Set the times to end at.
  assign name=t_final_arr n.value=(1e-9, 2e-9, 5e-9, 10e-9)
  # Set the maximum time-step. This represents the intervals over which the
  # simulation runs, in order to get from t_step to t_final. In a sense, this
  # seems to control the "resolution" of the simulations.
  # TODO: Should this be tweaked?
  assign name=dt_max n.value=0.5e-10

  # Reconfigure the solving method.
  method newton carriers=2 trap itlimit=20 maxtraps=10 dt.max=$dt_max
  solve tstep=$t_step tfinal=$t_final_arr
  save outf=${exp_name}_after${t_final_arr}s.sta

  # Alleviate the issue of redundancy by storing where we left of, so we can
  # pick back up, next iteration.
  set last_tfinal=$t_final_arr
l.end

# Run simulations over a constant time delta. 20ns is a pretty good interval to
# start with. With a delta of 20ns, for the number of loop steps, ~30 is good
# for collecting a baseline (and ensuring that enough data is collected), going
# up to >600ns. For non-baseline data collection, ~8 is enough;
#
# From last loop to this loop, it would be possible to prevent redundancy, but
# doing so could result in messy filenames. For example, if we picked up at
# 1ns and ran with a delta of 25ns, then that 1ns will be added to all of the
# "after" suffixes.

# for diode, run to 50ns
# run for differnt b.densities
# must go for much longer
set delta=33e-9
loop steps=15
  assign name=t_step n.value=0 delta=$delta
  assign name=t_final n.value=$t_step+$delta delta=$delta
  # increase by .5
  assign name=dt_max n.value=0.5e-9

  # Reconfigure the solving method.
  method newton carriers=2 trap itlimit=20 maxtraps=10 dt.max=$dt_max
  solve tstep=$t_step tfinal=$t_final
  save outf=${exp_name}_after${t_final}s.sta
l.end

